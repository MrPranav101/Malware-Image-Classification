from tensorflow.keras.applications import VGG16, InceptionV3, ResNet50
import tensorflow as tf
from tensorflow.keras.regularizers import l2
import metrics
IMG_SIZE = 128
NUM_CLASSES = 25


class MalwareModelsDispatcher:
    def __init__(self, optimizer='adam', loss_fn='categorical_crossentropy'):
        self.img_shape = (IMG_SIZE, IMG_SIZE, 3)
        self.optimizer = optimizer
        self.loss_fn = loss_fn

    def get_top(self, top_type ="SVM"):
        if top_type == "SVM":
            activation = "linear"
        else:
            activation = "softmax"
        global_average_layer = tf.keras.layers.GlobalAveragePooling2D()
        prediction_layer = tf.keras.layers.Dense(NUM_CLASSES, activation=activation)
        return [global_average_layer, prediction_layer]

    def compile(self, model):
        model.compile(loss=self.loss_fn, optimizer=self.optimizer,
                      metrics=['accuracy', metrics.f1_m, metrics.precision_m, metrics.recall_m])
        return model

    def vgg16_model(self):
        model = VGG16(input_shape=self.img_shape,
                      include_top=False,
                      weights='imagenet')

        model.trainable = False
        top = self.get_top()
        model = tf.keras.Sequential([model]+top)
        model = self.compile(model)
        return model

    def inceptionv3_model(self):
        model = InceptionV3(input_shape=self.img_shape,
                            include_top=False,
                            weights='imagenet')

        model.trainable = False
        top = self.get_top()
        model = tf.keras.Sequential([model] + top)
        model = self.compile(model)
        return model
    
    def svm_top(self):
        global_average_layer = tf.keras.layers.GlobalAveragePooling2D()
        prediction_layer = tf.keras.layers.Dense(NUM_CLASSES, activation='linear')
        return  [global_average_layer, prediction_layer]
    
    def CNNSVM_model(self):
        model = tf.keras.models.Sequential()
        model.add(tf.keras.layers.Conv2D(24, (5, 5), activation='relu', input_shape=self.img_shape))
        model.add(tf.keras.layers.MaxPooling2D((2, 2)))
        model.add(tf.keras.layers.Conv2D(12, (2, 2), activation='relu'))
        model.add(tf.keras.layers.MaxPooling2D((2, 2)))
        model.add(tf.keras.layers.Conv2D(8, (5, 5), activation='relu'))
        model.add(tf.keras.layers.MaxPooling2D((2, 2)))
        model.add(tf.keras.layers.Conv2D(4, (2, 2), activation='relu'))

        top = self.get_top(top_type="SVM")
        model = tf.keras.Sequential([model] + top)
        model = self.compile(model)
        return model
    
    def MLPSVM_model(self):
        model = tf.keras.models.Sequential()
        model.add(tf.keras.layers.Flatten(input_shape=self.img_shape))
        model.add(tf.keras.layers.Dense(500, activation=tf.keras.activations.relu))
        model.add(tf.keras.layers.Dense(250, activation=tf.keras.activations.relu))
        model.add(tf.keras.layers.Dense(100, activation=tf.keras.activations.relu))
        model.add(tf.keras.layers.Dense(NUM_CLASSES, activation="linear"))
        model = self.compile(model)
        return model

    # def GRUSVM_model(self):
    #     model = tf.keras.models.Sequential()
    #     model.add(tf.keras.layers.Flatten(input_shape=self.img_shape))
    #     model.add(tf.keras.layers.GRU(64, activation ='relu'))
    #     model.add(tf.keras.layers.Dense(NUM_CLASSES, activation="linear"))
    #     model = self.compile(model)
    #     return model